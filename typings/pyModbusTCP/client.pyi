"""
This type stub file was generated by pyright.
"""

from typing import List, Optional


class ModbusClient:
    """Modbus TCP client"""

    def __init__(self, host: str = ..., port: int = ..., unit_id: Optional[int] = ..., timeout: Optional[float] = ..., debug: Optional[bool] = ..., auto_open: Optional[bool] = ..., auto_close: Optional[bool] = ...) -> None:
        """Constructor

        Modbus server params (host, port) can be set here or with host(), port()
        functions. Same for debug option.

        Use functions avoid to launch ValueError except if params is incorrect.

        :param host: hostname or IPv4/IPv6 address server address (optional)
        :type host: str
        :param port: TCP port number (optional)
        :type port: int
        :param unit_id: unit ID (optional)
        :type unit_id: int
        :param timeout: socket timeout in seconds (optional)
        :type timeout: float
        :param debug: debug state (optional)
        :type debug: bool
        :param auto_open: auto TCP connect (optional)
        :type auto_open: bool
        :param auto_close: auto TCP close (optional)
        :type auto_close: bool
        :return: Object ModbusClient
        :rtype: ModbusClient
        :raises ValueError: if a set parameter value is incorrect
        """
        ...

    def version(self):
        """Get package version

        :return: current version of the package (like "0.0.1")
        :rtype: str
        """
        ...

    def last_error(self):
        """Get last error code

        :return: last error code
        :rtype: int
        """
        ...

    def last_except(self):
        """Get last except code

        :return: last except code
        :rtype: int
        """
        ...

    def host(self, hostname=...):
        """Get or set host (IPv4/IPv6 or hostname like 'plc.domain.net')

        :param hostname: hostname or IPv4/IPv6 address or None for get value
        :type hostname: str or None
        :returns: hostname or None if set fail
        :rtype: str or None
        """
        ...

    def port(self, port=...):
        """Get or set TCP port

        :param port: TCP port number or None for get value
        :type port: int or None
        :returns: TCP port or None if set fail
        :rtype: int or None
        """
        ...

    def unit_id(self, unit_id=...):
        """Get or set unit ID field

        :param unit_id: unit ID (0 to 255) or None for get value
        :type unit_id: int or None
        :returns: unit ID or None if set fail
        :rtype: int or None
        """
        ...

    def timeout(self, timeout=...):
        """Get or set timeout field

        :param timeout: socket timeout in seconds or None for get value
        :type timeout: float or None
        :returns: timeout or None if set fail
        :rtype: float or None
        """
        ...

    def debug(self, state=...):
        """Get or set debug mode

        :param state: debug state or None for get value
        :type state: bool or None
        :returns: debug state or None if set fail
        :rtype: bool or None
        """
        ...

    def auto_open(self, state=...):
        """Get or set automatic TCP connect mode

        :param state: auto_open state or None for get value
        :type state: bool or None
        :returns: auto_open state or None if set fail
        :rtype: bool or None
        """
        ...

    def auto_close(self, state=...):
        """Get or set automatic TCP close mode (after each request)

        :param state: auto_close state or None for get value
        :type state: bool or None
        :returns: auto_close state or None if set fail
        :rtype: bool or None
        """
        ...

    def mode(self, mode=...):
        """Get or set modbus mode (TCP or RTU)

        :param mode: mode (MODBUS_TCP/MODBUS_RTU) to set or None for get value
        :type mode: int
        :returns: mode or None if set fail
        :rtype: int or None
        """
        ...

    def open(self) -> bool:
        """Connect to modbus server (open TCP connection)

        :returns: connect status (True if open)
        :rtype: bool
        """
        ...

    def is_open(self):
        """Get status of TCP connection

        :returns: status (True for open)
        :rtype: bool
        """
        ...

    def close(self) -> Optional[bool]:
        """Close TCP connection

        :returns: close status (True for close/None if already close)
        :rtype: bool or None
        """
        ...

    def read_coils(self, bit_addr, bit_nb=...):
        """Modbus function READ_COILS (0x01)

        :param bit_addr: bit address (0 to 65535)
        :type bit_addr: int
        :param bit_nb: number of bits to read (1 to 2000)
        :type bit_nb: int
        :returns: bits list or None if error
        :rtype: list of bool or None
        """
        ...

    def read_discrete_inputs(self, bit_addr: int, bit_nb: int = ...) -> Optional[List[bool]]:
        """Modbus function READ_DISCRETE_INPUTS (0x02)

        :param bit_addr: bit address (0 to 65535)
        :type bit_addr: int
        :param bit_nb: number of bits to read (1 to 2000)
        :type bit_nb: int
        :returns: bits list or None if error
        :rtype: list of bool or None
        """
        ...

    def read_holding_registers(self, reg_addr, reg_nb=...):
        """Modbus function READ_HOLDING_REGISTERS (0x03)

        :param reg_addr: register address (0 to 65535)
        :type reg_addr: int
        :param reg_nb: number of registers to read (1 to 125)
        :type reg_nb: int
        :returns: registers list or None if fail
        :rtype: list of int or None
        """
        ...

    def read_input_registers(self, reg_addr, reg_nb=...):
        """Modbus function READ_INPUT_REGISTERS (0x04)

        :param reg_addr: register address (0 to 65535)
        :type reg_addr: int
        :param reg_nb: number of registers to read (1 to 125)
        :type reg_nb: int
        :returns: registers list or None if fail
        :rtype: list of int or None
        """
        ...

    def write_single_coil(self, bit_addr: int, bit_value: bool) -> Optional[bool]:
        """Modbus function WRITE_SINGLE_COIL (0x05)

        :param bit_addr: bit address (0 to 65535)
        :type bit_addr: int
        :param bit_value: bit value to write
        :type bit_value: bool
        :returns: True if write ok or None if fail
        :rtype: bool or None
        """
        ...

    def write_single_register(self, reg_addr, reg_value):
        """Modbus function WRITE_SINGLE_REGISTER (0x06)

        :param reg_addr: register address (0 to 65535)
        :type reg_addr: int
        :param reg_value: register value to write
        :type reg_value: int
        :returns: True if write ok or None if fail
        :rtype: bool or None
        """
        ...

    def write_multiple_coils(self, bits_addr, bits_value):
        """Modbus function WRITE_MULTIPLE_COILS (0x0F)

        :param bits_addr: bits address (0 to 65535)
        :type bits_addr: int
        :param bits_value: bits values to write
        :type bits_value: list
        :returns: True if write ok or None if fail
        :rtype: bool or None
        """
        ...

    def write_multiple_registers(self, regs_addr, regs_value):
        """Modbus function WRITE_MULTIPLE_REGISTERS (0x10)

        :param regs_addr: registers address (0 to 65535)
        :type regs_addr: int
        :param regs_value: registers values to write
        :type regs_value: list
        :returns: True if write ok or None if fail
        :rtype: bool or None
        """
        ...
