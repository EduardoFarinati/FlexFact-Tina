from pathlib import Path

from petri_net import (
    InputArc,
    InputArcTypes,
    OutputArc,
    PetriNet,
    Place,
    Tokens,
    Transition,
)


def get_or_insert_place(network: PetriNet, place_name: str) -> Place:
    place = network.get_place(place_name)
    if not place:
        place = Place(place_name, Tokens(0))
        network.add_place(place)

    return place


def parse(filepath: Path) -> PetriNet:
    """Parse the text file generated by tina export."""

    network = PetriNet()

    with open(filepath, "r") as file:
        for line in file:
            elements = (
                line.strip()
                .replace("\n", "")
                .replace("\r", "")
                .replace("{", "")
                .replace("}", "")
                .split()
            )

            if len(elements) == 0:
                continue
            elif elements[0] == "tr":
                transition = Transition(elements[1])
                arrow_index = elements.index("->")
                for element in elements[3:arrow_index]:
                    if "?" in element:
                        place_name, weight = element.split("?", 1)
                        place = get_or_insert_place(network, place_name)

                        if int(weight) > 0:
                            transition.input_arcs.append(
                                InputArc(
                                    place,
                                    Tokens(int(weight)),
                                    InputArcTypes.READ,
                                )
                            )
                        else:
                            transition.input_arcs.append(
                                InputArc(
                                    place,
                                    Tokens(abs(int(weight))),
                                    InputArcTypes.INHIBITOR,
                                )
                            )
                    else:
                        parts = element.split("*")

                        place_name = parts[0]
                        place = get_or_insert_place(network, place_name)

                        if len(parts) == 1:
                            transition.input_arcs.append(
                                InputArc(
                                    place, Tokens(1), InputArcTypes.REGULAR
                                )
                            )
                        else:
                            weight = parts[1]
                            transition.input_arcs.append(
                                InputArc(
                                    place,
                                    Tokens(int(weight)),
                                    InputArcTypes.REGULAR,
                                )
                            )

                if arrow_index + 1 != len(elements):
                    for element in elements[arrow_index + 1 :]:
                        parts = element.split("*")

                        place_name = parts[0]
                        place = get_or_insert_place(network, place_name)

                        if len(parts) == 1:
                            transition.output_arcs.append(
                                OutputArc(place, Tokens(1))
                            )
                        else:
                            weight = parts[1]
                            transition.output_arcs.append(
                                OutputArc(place, Tokens(int(weight)))
                            )

                network.add_transition(transition)

            elif elements[0] == "pl":
                place_name = elements[1]
                marking = int(elements[2].replace("(", "").replace(")", ""))

                place = get_or_insert_place(network, place_name)
                place.tokens = Tokens(marking)

    return network
